##Realm数据库

[Realm官方文档](https://realm.io/cn/docs/objc/latest/)	
[Realm基本知识](https://blog.csdn.net/zhang522802884/article/details/77197887)	
[Realm数据库 从入门到“放弃”](https://www.jianshu.com/p/50e0efb66bdf)

Realm是一个类MVCC数据库，每个连接的线程在特定的时刻都有一个数据库的快照。零拷贝架构也使得Realm可以自动更新对象和查询。在一个查询中更新对象，在另外一个查询中可以马上读取到更新的内容。多线程同时更新数据也是一样，可以即时更新对象的内容。正是因为对象的自动更新，所以Realm中也是不允许多线程之间的对象共享，因为如果多线程共享Realm对象，会导致数据的不一致性，虽然通过加锁是可以保证数据一致性的，但是会增加开销。

因此，在使用Realm的时候，不要在多个线程之间共享对象。如果要在另外一个线程获取同样的数据，请重新执行查询。负责很可能会导致程序崩溃。


###需要注意的点：		
1、在使用Realm的时候，不要在多个线程之间共享对象。	
2、请注意数据迁移的操作，realm数据库的config配置会有一个schemeVersion来标示每一个版本和上一个版本时候是否需要进行数据迁移，如果需要会走数据迁移的block，在主线程进行数据迁移。分为两种情况：1、新增字段、值修改、重命名等操作可以直接修改新值。而比如修改主键、既有字段修改类型、以及字段从可空修改为非可空等操作需要创建新架构的realm数据库，然后将旧数据拷贝到新的数据库中去。	
3、可以注册一个监听器，realm或者实体发生变化的时候可以接收相应的通知。如果有引用持有返回的通知令牌，会对其传递通知，而一旦通知令牌被释放，通知也会自动取消注册。并且通知只在最初注册的线程传递，并且该线程必须拥有一个正在运行的Runloop。通知是被异步调用的，是通过runloop传递的，因此可能回延时传递，也有可能多个更改的通知合并到一个。	
4、realm与线程：Realm 读取事务的生命周期与 RLMRealm 实例的生命周期相关联。避免使用自动刷新 Realm 数据库，以及在显式自动释放池中从后台进程封装所有的 Realm API 使用，以达成“固定”旧有 Realm 事务的目的。		
在主 UI 线程中（或者任何一个位于 runloop 中的线程），对象会在 runloop 的每次循环过程中自行获取其他线程造成的更改。其余时候您只能够对快照进行操作，因此单个方法中得到的数据将始终不变，无需担心其他线程会对其造成影响。	
4.1 RLMObject 的未管理实例（unmanaged) 表现的和正常的 NSObject 子类相同，可以安全地跨线程传递。	
RLMRealm、RLMObject、RLMResults 或者 RLMArray 受管理实例皆受到线程的限制，这意味着它们只能够在被创建的线程上使用，否则就会抛出异常。这是 Realm 强制事务版本隔离的一种方法。否则，在不同事务版本中的线程间，通过潜在泛关系图 (potentially extensive relationship graph) 来确定何时传递对象将不可能实现。意思就是不能随意的跨线程传递对象。可以使用RLMThreadSafeReference传递，但如果传递失败会造成realm原始版本被锁死，直到引用被释放。

4.2 Realm在指定线程获取的数据，如果其他线程改变数据，那么获取到的数据也会改变。但是需要注意的是获取到的数据只能在获取数据的线程使用，不能跨线程使用。

5、JSON
realm没有提供json的直接支持，但是您可以使用 [NSJSONSerialization JSONObjectWithData:options:error:] 的输出，实现将 JSON 添加到 RLMObject 的操作。如果在 JSON 中包含了嵌套的对象或者数组的话，这些数据都将被自动映射到对一以及对多关系。当使用这种方法在 Realm 中插入或者更新 JSON 数据的时候，要注意 Realm 需要确保 JSON 的属性名和类型能够与 RLMObject 属性完全匹配。

###realm数据库的限制：
1、存储的限制：类名称的长度最大只能存储 57 个 UTF8 字符；属性名称的长度最大只能支持 63 个 UTF8 字符；NSData 和 NSString 属性不能保存超过 16 MB 大小的数据。	
2、线程：尽管 Realm 文件可以被多个线程同时访问，但是您不能直接跨线程传递 Realms、Realm 对象、查询和查询结果。如果您需要跨线程传递 Realm 对象的话，您可以使用 RLMThreadSafeReference API。	
3、模型：因为 Realm 在底层数据库中重写了 setters 和 getters 方法，所以您不可以在您的对象上再对其进行重写。如果属性被标识为ignore，则该属性的get和set方法可以被重写的。      		realm没有自动增长的属性，因此对于主键，可以使用[[NSUUID UUID] UUIDString]产生一个唯一的字符串ID。	
4、文件大小：realm数据库会在runloop开始的时候更新，因此不需要设置自动更新。如果数据库过大，可能是因为你在一个子线程中进行了realm数据库的读操作，然后该线程一直在执行一个一个长时间的任务。然后再另外的线程中更新了数据，那么此时数据库就会维持一个数据库的副本，增大了存储空间。但实际上这个副本是不需要的。为了避免这个问题，可以调用invalidate。	
在使用GCD的时候，可以把读写放在autorelease pool进行操作。
