#iOS库及多工程联编 

>库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。

什么时候我们会用到库呢？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。
##库的分类
### 静态库
>静态库即静态链接库（.lib(Windows)，a(Linux/Mac)）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。

### 动态库
>动态库即动态链接库（.dll(windows)，.dylib(mac)，so(linux)）.编译时不会被拷贝，只存储动态库的应用，程序运行时，动态库才会被加载进来。

framework(in Apple): Framework 是Cocoa/Cocoa Touch程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。也就是说我们的 framework其实是资源打包的方式，和静态库动态库的本质是没有关系的

### 优缺点对比
>静态库编译完成后目标程序没有外部依赖，直接可以运行。缺点是会使目标程序的体积变大。
>
>动态库链接时不复制，因此可以有效的减小程序包的体积。在程序启动后用dyld加载，然后再决议符号，所以理论上动态库只用存在一份，好多个程序都可以动态链接到这个动态库上面，达到了节省内存(不是磁盘是内存中只有一份动态库)。还有另外一个好处，由于动态库并不绑定到可执行程序上，所以我们想升级这个动态库就很容易，windows和linux上面一般插件和模块机制都是这样实现的。iOS8之前苹果不允许使用动态库，iOS8 swift只能使用动态库，出现了APP Extensions，因此苹果在iOS8支持使用动态库(Embedded Framework)，允许APP和APP Extensions共享代码，但是动态库的生命周期被限定在一个APP进程内。

## 库的生成
基础的静态库和动态库的生成方法类似。包括：
>1、选择库模板生成一个库的workSpace。

>2、添加文件，类别，以及第三方库,设置库的依赖关系,添加的第三方库的链接flags（和正常项目使用第三方库类似）。

>3、选择编译配置，设置合适的CPU架构（设置build Active Architecture Only 为NO）。

>4、编译生成模拟器和真机库，并通过命令行合并；或者我们可以通过脚本直接生成合并后的库。

库的相互依赖
>1、静态库相互依赖。制作静态库的时候只需要有被依赖的静态库头文件在就能编译出来。
>
>2、动态库依赖动态库，两个动态库是相互隔离的具有隔离性，但是制作的静态库的时候需要被依赖动态库参与链接，但是具体的符号决议交给dyld来做。
>
>3、静态库依赖动态库，也很常见，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。
>
>4、动态库依赖静态库。动态库编译的时候需要静态库参与编译，但是静态库不应该交由dyld来做符号决议。静态库本质是一堆.o 的打包体，并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。目前，编译器的解决方法是，把静态库的.o文件拿过来，共同生成新的二进制。也被称为吸附性。但如果多份动态库包含了同样的静态库，会因为吸附性需要同一份的.o文件出错。解决的办法是自定义一个动态库吸附需要的静态库，对外呈现动态库的特性，其他组件依赖我们自定义的动态库。

资源文件（需要验证）
>动态库中使用Bundle存放资源文件，可用于多人合作开发，避免资源重名。里面可以存储xib文、资源图片等。Bundle文件是静态的，不进行编译的。所以使用Bundle中的资源，就需要找到相应的资源路径。
>
>.a文件中无法使用Bundle文件，只能另存一个文件。


## 库的管理（Cocapods）
Cocoapods是一个开源的针对iOS项目的依赖管理工具。
>[Cocoapods的安装及简单使用](https://www.jianshu.com/p/9e4e36ba8574)

>[编译参数设置](http://www.cnblogs.com/xiaodao/archive/2012/03/28/2422091.html)

>[Cocoapods原理总结](https://juejin.im/entry/59dd94b06fb9a0451463030b)
>Cocoapods管理依赖库，Xcode项目只能使用workspace编译项目，因为此时项目的库的依赖关系已经发生了变化。Cocoapods会构建Pods工程，此工程下每个第三方工程对应一个target，这个工程还有一个Pods-xxx的target的target。此时项目的target会依赖Pods工程的Pods-xxx编译出来的库，而Pods-xxx则依赖通过pods引入的其他第三方库，如此就实现了库的依次编译。



解除依赖库
>sudo gem install cocoapods-deintegrate

>pod deintegrate

## 子工程联编及Submodule的使用

## 用到的脚本


## 参考文章
1、[iOS 动态库和静态库的的区别 动态库的隔离与静态库的吸附问题以及解决方法](http://blog.csdn.net/clovejq/article/details/71107796?utm_source=itdadao&utm_medium=referral)

2、[iOS中的dyld缓存](http://blog.csdn.net/gaoyuqiang30/article/details/52536168)

3、[Cocoapods原理总结](https://juejin.im/entry/59dd94b06fb9a0451463030b)